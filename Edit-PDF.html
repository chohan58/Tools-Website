<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PDF Editor — Full Editor (Export, Draw, Text, Shapes)</title>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css"/>
<style>
  /* --- Keep the look & feel similar to your original --- */
  *{box-sizing:border-box;font-family:"Segoe UI",Tahoma,Arial,sans-serif}
  body{background:linear-gradient(135deg,#6a11cb 0%,#2575fc 100%);margin:0;min-height:100vh;color:#222;padding:20px;display:flex;justify-content:center}
  .container{width:100%;max-width:1200px}
  .home-page{text-align:center;color:#fff;margin-bottom:18px}
  .home-page h1{font-size:2.2rem;margin-bottom:6px}
  .btn{background:#3498db;color:#fff;border:none;padding:10px 14px;border-radius:8px;cursor:pointer}
  .btn.secondary{background:#95a5a6}
  .upload-page{background:#fff;border-radius:12px;padding:18px;margin-top:12px;box-shadow:0 10px 30px rgba(0,0,0,.12)}
  .upload-area{border:2px dashed #9bbad6;border-radius:10px;padding:24px;text-align:center;cursor:pointer;background:#f8fbff}
  .editor-container{display:none;background:#fff;border-radius:12px;padding:0;margin-top:18px;box-shadow:0 10px 30px rgba(0,0,0,.12);overflow:hidden}
  .toolbar{background:#2c3e50;color:#fff;padding:12px;display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .toolbar .group{display:flex;gap:8px;align-items:center;padding-right:12px;border-right:1px solid rgba(255,255,255,.06)}
  .toolbar button{background:#3498db;border:none;color:#fff;padding:8px 10px;border-radius:6px;cursor:pointer}
  .tool-active{outline:2px solid #7ec8ff}
  .pdf-viewer{height:70vh;overflow:auto;background:#f0f3f5;display:flex;justify-content:center;padding:18px}
  .pdf-page{position:relative;background:#fff;box-shadow:0 6px 20px rgba(0,0,0,.08);width:816px;margin:0 auto;overflow:visible}
  canvas#pdf-canvas{display:block}
  canvas.overlay{position:absolute;left:0;top:0;pointer-events:none}
  canvas.drawing{pointer-events:auto}
  .status{background:#ecf0f1;padding:10px 14px;border-top:1px solid #e2e8f0;display:flex;justify-content:space-between;align-items:center}
  .controls{display:flex;gap:8px;align-items:center}
  .submenu{background:#fff;padding:10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,.12);display:flex;gap:8px;align-items:center}
  .color-input{width:36px;height:34px;border:none;padding:0;cursor:pointer}
  .small{padding:6px 8px;font-size:13px}
  .textbox-container{position:absolute;border:1px solid #3498db;border-radius:6px;padding:4px;background:rgba(255,255,255,0.98);resize:both;overflow:auto}
  .textbox-container textarea{width:100%;height:100%;border:none;background:transparent;outline:none;resize:none}
  .toast{position:fixed;left:50%;transform:translateX(-50%);bottom:20px;background:#222;color:#fff;padding:8px 12px;border-radius:8px;opacity:0;transition:opacity .25s}
  .toast.show{opacity:1}
  .file-controls{display:flex;gap:8px;align-items:center}
  /* responsive */
  @media (max-width:900px){ .pdf-page{width:90vw} }
</style>
</head>
<body>
<div class="container">
  <div id="home" class="home-page">
    <h1>PDF Editor Plugin — Full Editor</h1>
    <p>Upload, annotate, export — all in the browser</p>
    <button id="go-edit" class="btn"><i class="fas fa-edit"></i> EDIT PDF</button>
  </div>

  <div id="upload" class="upload-page" style="display:none">
    <h3>Upload a PDF</h3>
    <div id="uploadArea" class="upload-area">
      <p><i class="fas fa-file-upload fa-2x"></i></p>
      <p>Click here or drag & drop a PDF file</p>
      <input id="fileInput" type="file" accept="application/pdf" style="display:none"/>
    </div>
    <div style="margin-top:12px;display:flex;gap:8px">
      <button id="backHome" class="btn secondary"><i class="fas fa-arrow-left"></i> Back</button>
    </div>
  </div>

  <div id="editor" class="editor-container" aria-hidden="true">
    <div class="toolbar">
      <div class="group">
        <button id="saveBtn" class="small btn"><i class="fas fa-save"></i> Save</button>
        <button id="printBtn" class="small btn"><i class="fas fa-print"></i> Print</button>
      </div>

      <div class="group">
        <button id="toolSelect" class="small btn tool-active"><i class="fas fa-mouse-pointer"></i> Select</button>
        <button id="toolDraw" class="small btn"><i class="fas fa-pen"></i> Draw</button>
        <button id="toolText" class="small btn"><i class="fas fa-font"></i> Text</button>
        <button id="toolShape" class="small btn"><i class="fas fa-square-root-alt"></i> Shapes</button>
        <button id="toolHighlight" class="small btn"><i class="fas fa-highlighter"></i> Highlight</button>
      </div>

      <div class="group submenu">
        <label>Color</label>
        <input id="colorPick" class="color-input" type="color" value="#ff2d2d" title="Primary color">
        <label>Width</label>
        <input id="widthPick" type="number" value="3" min="1" max="40" style="width:64px;padding:6px;border-radius:6px;border:1px solid #ddd">
        <button id="undoBtn" class="small btn"><i class="fas fa-undo"></i></button>
        <button id="redoBtn" class="small btn"><i class="fas fa-redo"></i></button>
      </div>

      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div class="file-controls">
          <button id="exportJSON" class="small btn">Export JSON</button>
          <button id="importJSON" class="small btn">Import JSON</button>
          <input id="importFile" type="file" accept="application/json" style="display:none"/>
        </div>
        <div>
          <button id="zoomOut" class="small btn">-</button>
          <button id="zoomReset" class="small btn">100%</button>
          <button id="zoomIn" class="small btn">+</button>
        </div>
      </div>
    </div>

    <div class="pdf-viewer" id="viewer">
      <div class="pdf-page" id="pageRoot">
        <canvas id="pdf-canvas"></canvas>
        <!-- overlay canvases (annotation raster, drawing) -->
        <canvas id="anno-canvas" class="overlay"></canvas>
        <canvas id="draw-canvas" class="overlay drawing"></canvas>
        <!-- textboxes/shapes will be DOM elements appended here -->
      </div>
    </div>

    <div class="status">
      <div>Page <span id="pageNum">1</span> / <span id="pageCount">1</span></div>
      <div class="controls">
        <button id="prevPage" class="small btn"><i class="fas fa-chevron-left"></i> Prev</button>
        <button id="nextPage" class="small btn">Next <i class="fas fa-chevron-right"></i></button>
      </div>
    </div>
  </div>

</div>

<div id="toast" class="toast"></div>

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.5.136/pdf.min.js"></script>
<script src="https://unpkg.com/pdf-lib/dist/pdf-lib.min.js"></script>

<script>
/* =========================
   Full PDF Editor Script
   =========================
   Features:
   - Upload (drag/drop + file picker)
   - Render with PDF.js (worker configured)
   - Drawing overlay with color/width, undo/redo
   - Text boxes (dblclick to add), draggable/resizable
   - Shapes: rect/ellipse/arrow (simple)
   - Highlight rectangles
   - Export/Import annotations JSON
   - Save: flatten annotations into new PDF using pdf-lib
*/

/* ---------- Config & State ---------- */
pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.5.136/pdf.worker.min.js';

const state = {
  pdfDoc: null,
  pdfBytes: null,        // original uploaded ArrayBuffer
  pageNum: 1,
  pageCount: 1,
  scale: 1.2,
  fileName: 'edited.pdf',
  tool: 'select',        // select | draw | text | shape | highlight
  draw: {color:'#ff2d2d', width:3},
  undoStack: [], redoStack: [],
  annotations: {}, // per-page arrays of annotation objects
  currentShape: null
};

/* ---------- Elements ---------- */
const goEdit = document.getElementById('go-edit');
const home = document.getElementById('home');
const upload = document.getElementById('upload');
const uploadArea = document.getElementById('uploadArea');
const fileInput = document.getElementById('fileInput');
const editor = document.getElementById('editor');
const pdfCanvas = document.getElementById('pdf-canvas');
const pdfCtx = pdfCanvas.getContext('2d');
const annoCanvas = document.getElementById('anno-canvas');
const annoCtx = annoCanvas.getContext('2d');
const drawCanvas = document.getElementById('draw-canvas');
const drawCtx = drawCanvas.getContext('2d');
const pageRoot = document.getElementById('pageRoot');
const pageNumEl = document.getElementById('pageNum');
const pageCountEl = document.getElementById('pageCount');
const toastEl = document.getElementById('toast');

/* Controls */
const saveBtn = document.getElementById('saveBtn');
const printBtn = document.getElementById('printBtn');
const toolSelect = document.getElementById('toolSelect');
const toolDraw = document.getElementById('toolDraw');
const toolText = document.getElementById('toolText');
const toolShape = document.getElementById('toolShape');
const toolHighlight = document.getElementById('toolHighlight');
const colorPick = document.getElementById('colorPick');
const widthPick = document.getElementById('widthPick');
const undoBtn = document.getElementById('undoBtn');
const redoBtn = document.getElementById('redoBtn');
const exportJSON = document.getElementById('exportJSON');
const importJSON = document.getElementById('importJSON');
const importFile = document.getElementById('importFile');
const zoomIn = document.getElementById('zoomIn');
const zoomOut = document.getElementById('zoomOut');
const zoomReset = document.getElementById('zoomReset');
const prevPage = document.getElementById('prevPage');
const nextPage = document.getElementById('nextPage');

/* ---------- Utilities ---------- */
function showToast(msg, t=1800){ toastEl.textContent = msg; toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), t); }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function clearCanvas(cctx){ cctx.clearRect(0,0,cctx.canvas.width, cctx.canvas.height); }

/* ---------- UI Wiring (views) ---------- */
goEdit.addEventListener('click', ()=>{ home.style.display='none'; upload.style.display='block'; });
document.getElementById('backHome').addEventListener('click', ()=>{ home.style.display='block'; upload.style.display='none'; editor.style.display='none'; });

/* ---------- Upload handling ---------- */
uploadArea.addEventListener('click', ()=> fileInput.click());
fileInput.addEventListener('change', e => {
  if(e.target.files && e.target.files[0]) loadPdfFile(e.target.files[0]);
  e.target.value = '';
});
['dragenter','dragover'].forEach(ev=> uploadArea.addEventListener(ev, e=> { e.preventDefault(); uploadArea.style.borderColor='#3498db'; }));
['dragleave','drop'].forEach(ev=> uploadArea.addEventListener(ev, e=> { e.preventDefault(); uploadArea.style.borderColor='#9bbad6'; }));
uploadArea.addEventListener('drop', e => {
  const f = e.dataTransfer.files[0]; if(f) loadPdfFile(f);
});

/* ---------- PDF Loading & Rendering ---------- */
async function loadPdfFile(file){
  if(!(file.type==='application/pdf' || file.name.toLowerCase().endsWith('.pdf'))){
    showToast('Please upload a PDF file');
    return;
  }
  showToast('Loading PDF...');
  state.fileName = file.name.replace(/\.pdf$/i,'') + '_edited.pdf';
  const ab = await file.arrayBuffer();
  state.pdfBytes = ab;
  try {
    const loadingTask = pdfjsLib.getDocument({data:ab});
    state.pdfDoc = await loadingTask.promise;
    state.pageCount = state.pdfDoc.numPages;
    state.pageNum = 1;
    pageCountEl.textContent = state.pageCount;
    await renderPage();
    upload.style.display='none';
    editor.style.display='block';
    showToast('PDF loaded');
  } catch(err){
    console.error('PDF load error', err);
    showToast('Failed to load PDF');
  }
}

async function renderPage(){
  const page = await state.pdfDoc.getPage(state.pageNum);
  const viewport = page.getViewport({scale: state.scale});
  // HiDPI handling
  const ratio = window.devicePixelRatio || 1;
  pdfCanvas.width = Math.floor(viewport.width * ratio);
  pdfCanvas.height = Math.floor(viewport.height * ratio);
  pdfCanvas.style.width = `${Math.floor(viewport.width)}px`;
  pdfCanvas.style.height = `${Math.floor(viewport.height)}px`;
  pdfCtx.setTransform(ratio,0,0,ratio,0,0);

  const renderTask = page.render({canvasContext: pdfCtx, viewport});
  await renderTask.promise;

  // Size overlays to match
  resizeOverlays(viewport.width, viewport.height, ratio);

  // Redraw annotations for this page
  drawAllAnnotationsForPage(state.pageNum);
  pageNumEl.textContent = state.pageNum;
}

/* ---------- Overlay sizing ---------- */
function resizeOverlays(cssWidth, cssHeight, ratio){
  [annoCanvas, drawCanvas].forEach(cvs => {
    cvs.width = Math.floor(cssWidth * (ratio));
    cvs.height = Math.floor(cssHeight * (ratio));
    cvs.style.width = `${Math.floor(cssWidth)}px`;
    cvs.style.height = `${Math.floor(cssHeight)}px`;
    cvs.getContext('2d').setTransform(ratio,0,0,ratio,0,0);
    // position the canvas to (0,0) inside pageRoot
    cvs.style.left = '0px'; cvs.style.top = '0px';
  });
}

/* ---------- Annotation model ----------
 We'll store annotations as objects, per page:
 state.annotations[page] = [ { type:'drawing', imageDataUrl:..., }, {type:'textbox', x,y,w,h,html,font,color,...}, {type:'shape', shapeType:'rect'|'ellipse'|'arrow', x,y,w,h, stroke, fill, width}, ... ]
 ---------- */
function ensurePageAnnotations(page){ if(!state.annotations[page]) state.annotations[page]=[]; return state.annotations[page]; }

/* ---------- Drawing tool (freehand) ---------- */
let isPointerDown = false;
let lastPos = null;
drawCanvas.addEventListener('pointerdown', e => {
  if(state.tool !== 'draw') return;
  isPointerDown = true;
  const rect = drawCanvas.getBoundingClientRect();
  lastPos = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  drawCtx.beginPath(); drawCtx.moveTo(lastPos.x, lastPos.y);
});
drawCanvas.addEventListener('pointermove', e => {
  if(!isPointerDown || state.tool !== 'draw') return;
  const rect = drawCanvas.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  drawCtx.lineTo(x,y);
  drawCtx.strokeStyle = state.draw.color;
  drawCtx.lineWidth = Number(state.draw.width) || 3;
  drawCtx.lineCap = 'round';
  drawCtx.stroke();
  lastPos = {x,y};
});
['pointerup','pointercancel','pointerleave'].forEach(ev => drawCanvas.addEventListener(ev, e => {
  if(!isPointerDown) return;
  if(state.tool !== 'draw') { isPointerDown=false; return; }
  isPointerDown = false;
  // Save drawing as annotation (rasterized image of overlay)
  const ratio = window.devicePixelRatio || 1;
  // Create a copy of current drawCanvas as data URL (CSS sized)
  const cssW = drawCanvas.clientWidth, cssH = drawCanvas.clientHeight;
  // To preserve CSS pixel coordinates we create temporary canvas
  const tmp = document.createElement('canvas'); tmp.width = cssW; tmp.height = cssH;
  const tmpCtx = tmp.getContext('2d');
  // draw the drawing overlay onto tmp at CSS scale
  tmpCtx.drawImage(drawCanvas, 0, 0, cssW, cssH);
  const dataUrl = tmp.toDataURL('image/png');
  const ann = { type:'drawing', img: dataUrl };
  ensurePageAnnotations(state.pageNum).push(ann);
  pushUndo({action:'add', page:state.pageNum, ann});
  // clear drawCanvas (they are moved to anno layer)
  clearCanvas(drawCtx);
  drawAllAnnotationsForPage(state.pageNum);
  state.redoStack = [];
}));

/* ---------- Draw all annotations for a page (raster/DOM) ---------- */
function drawAllAnnotationsForPage(page){
  clearCanvas(annoCtx);
  // clear DOM textboxes/shapes (remove existing)
  Array.from(pageRoot.querySelectorAll('.textbox-container, .shape-dom')).forEach(n=>n.remove());
  const list = state.annotations[page] || [];
  list.forEach(item => {
    if(item.type === 'drawing'){
      // image data on annoCtx scaled to CSS
      const img = new Image();
      img.onload = ()=> {
        // draw fit to canvas
        annoCtx.drawImage(img, 0, 0, drawCanvas.clientWidth, drawCanvas.clientHeight);
      };
      img.src = item.img;
    } else if(item.type === 'textbox'){
      // create DOM element (absolute positioned)
      const el = document.createElement('div');
      el.className = 'textbox-container';
      el.style.left = item.x + 'px';
      el.style.top = item.y + 'px';
      el.style.width = item.w + 'px';
      el.style.height = item.h + 'px';
      el.style.borderColor = item.border || '#3498db';
      el.style.background = item.bg || 'rgba(255,255,255,0.98)';
      el.innerHTML = `<textarea>${item.text || ''}</textarea>`;
      pageRoot.appendChild(el);
      makeElementDraggableResizable(el, page);
    } else if(item.type === 'shape'){
      // either rasterize into anno canvas or create DOM overlay (we draw on annoCtx)
      annoCtx.save();
      annoCtx.beginPath();
      annoCtx.lineWidth = item.strokeWidth || 2;
      annoCtx.strokeStyle = item.stroke || '#000';
      annoCtx.fillStyle = item.fill || 'rgba(0,0,0,0)';
      if(item.shapeType === 'rect'){
        annoCtx.fillRect(item.x, item.y, item.w, item.h);
        annoCtx.strokeRect(item.x, item.y, item.w, item.h);
      } else if(item.shapeType === 'ellipse'){
        const cx = item.x + item.w/2, cy = item.y + item.h/2, rx = Math.abs(item.w/2), ry = Math.abs(item.h/2);
        annoCtx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2);
        annoCtx.fill(); annoCtx.stroke();
      } else if(item.shapeType === 'arrow'){
        // simple arrow: line + triangle head
        annoCtx.moveTo(item.x, item.y);
        annoCtx.lineTo(item.x + item.w, item.y + item.h);
        annoCtx.stroke();
        // head
        const ax = item.x + item.w, ay = item.y + item.h;
        annoCtx.beginPath();
        annoCtx.moveTo(ax, ay);
        annoCtx.lineTo(ax - 10, ay - 6);
        annoCtx.lineTo(ax - 6, ay - 10);
        annoCtx.closePath();
        annoCtx.fill();
      }
      annoCtx.restore();
    } else if(item.type === 'highlight'){
      annoCtx.save();
      annoCtx.fillStyle = item.color || 'rgba(255,255,0,0.35)';
      annoCtx.fillRect(item.x, item.y, item.w, item.h);
      annoCtx.restore();
    }
  });
}

/* ---------- Make DOM element draggable/resizable ---------- */
function makeElementDraggableResizable(el, page){
  el.style.position = 'absolute';
  el.style.cursor = 'move';
  let dragging=false, offsetX=0, offsetY=0;
  el.addEventListener('mousedown', e => {
    dragging = true; offsetX = e.offsetX; offsetY = e.offsetY; el.style.zIndex = 999;
  });
  document.addEventListener('mousemove', e => {
    if(!dragging) return;
    const rect = pageRoot.getBoundingClientRect();
    const nx = e.clientX - rect.left - offsetX, ny = e.clientY - rect.top - offsetY;
    el.style.left = nx + 'px'; el.style.top = ny + 'px';
  });
  document.addEventListener('mouseup', () => {
    if(dragging){
      dragging=false; el.style.zIndex = 10;
      // update annotation in model
      const idx = Array.from(pageRoot.querySelectorAll('.textbox-container')).indexOf(el);
      // we can't easily map to model index — instead, on save/export we read DOM elements into model
      updateTextboxesFromDOM(page);
    }
  });
  // resizable - CSS resize property works, but on mouseup we'll update model
  el.addEventListener('mouseup', ()=> updateTextboxesFromDOM(page));
}

/* ---------- Update textboxes model from DOM elements ---------- */
function updateTextboxesFromDOM(page){
  const nodes = Array.from(pageRoot.querySelectorAll('.textbox-container'));
  // remove existing textbox annotations and append fresh ones
  const anns = ensurePageAnnotations(page);
  // filter out textboxes in anns
  const nonText = anns.filter(a => a.type !== 'textbox');
  const newText = nodes.map(n => {
    const r = n.getBoundingClientRect();
    const pr = pageRoot.getBoundingClientRect();
    const x = r.left - pr.left, y = r.top - pr.top;
    const w = r.width, h = r.height;
    const text = n.querySelector('textarea').value;
    return { type:'textbox', x,y,w,h,text, border:'#3498db', bg:'#fff' };
  });
  state.annotations[page] = nonText.concat(newText);
  pushUndo({ action:'replaceTextbox', page, prev:anns, next: state.annotations[page]});
}

/* ---------- Tools switching ---------- */
function setTool(t){
  state.tool = t;
  document.querySelectorAll('.toolbar button').forEach(b=>b.classList.remove('tool-active'));
  if(t==='select') toolSelect.classList.add('tool-active');
  if(t==='draw') toolDraw.classList.add('tool-active');
  if(t==='text') toolText.classList.add('tool-active');
  if(t==='shape') toolShape.classList.add('tool-active');
  if(t==='highlight') toolHighlight.classList.add('tool-active');
  // set pointer events
  drawCanvas.style.pointerEvents = (t==='draw') ? 'auto' : 'none';
}
toolSelect.addEventListener('click', ()=> setTool('select'));
toolDraw.addEventListener('click', ()=> setTool('draw'));
toolText.addEventListener('click', ()=> setTool('text'));
toolShape.addEventListener('click', ()=> setTool('shape'));
toolHighlight.addEventListener('click', ()=> setTool('highlight'));

/* ---------- Textbox creation on double-click ---------- */
pageRoot.addEventListener('dblclick', e => {
  if(state.tool !== 'text') return;
  const rect = pageRoot.getBoundingClientRect();
  const x = e.clientX - rect.left, y = e.clientY - rect.top;
  const el = document.createElement('div');
  el.className = 'textbox-container';
  el.style.left = x + 'px'; el.style.top = y + 'px'; el.style.width='180px'; el.style.height='60px';
  el.innerHTML = '<textarea>Enter text</textarea>';
  pageRoot.appendChild(el);
  makeElementDraggableResizable(el, state.pageNum);
  // commit to annotations
  updateTextboxesFromDOM(state.pageNum);
  pushUndo({action:'add', page: state.pageNum, ann: {type:'textbox', x: x, y: y, w:180, h:60, text:'Enter text', border:'#3498db', bg:'#fff'}});
});

/* ---------- Shape & Highlight drawing (mouse drag) ---------- */
let shapeStart = null;
pageRoot.addEventListener('pointerdown', e => {
  if(!(state.tool === 'shape' || state.tool === 'highlight')) return;
  const rect = pageRoot.getBoundingClientRect();
  shapeStart = { x: e.clientX - rect.left, y: e.clientY - rect.top };
  pageRoot.setPointerCapture(e.pointerId);
});
pageRoot.addEventListener('pointermove', e => {
  if(!shapeStart) return;
  const rect = pageRoot.getBoundingClientRect();
  const cx = e.clientX - rect.left, cy = e.clientY - rect.top;
  // render preview on drawCanvas (clear first)
  clearCanvas(drawCtx);
  drawCtx.save();
  drawCtx.strokeStyle = state.draw.color;
  drawCtx.lineWidth = Number(state.draw.width) || 2;
  if(state.tool === 'shape'){
    // rectangle preview
    const w = cx - shapeStart.x, h = cy - shapeStart.y;
    drawCtx.strokeRect(shapeStart.x, shapeStart.y, w, h);
  } else if(state.tool === 'highlight'){
    drawCtx.fillStyle = hexToRgba(state.draw.color, 0.3);
    drawCtx.fillRect(shapeStart.x, shapeStart.y, cx - shapeStart.x, cy - shapeStart.y);
  }
  drawCtx.restore();
});
pageRoot.addEventListener('pointerup', e => {
  if(!shapeStart) return;
  const rect = pageRoot.getBoundingClientRect();
  const ex = e.clientX - rect.left, ey = e.clientY - rect.top;
  const x = shapeStart.x, y = shapeStart.y, w = ex - x, h = ey - y;
  if(state.tool === 'shape'){
    const ann = { type:'shape', shapeType:'rect', x, y, w, h, stroke: state.draw.color, fill:'rgba(0,0,0,0)', strokeWidth: Number(state.draw.width)||2 };
    ensurePageAnnotations(state.pageNum).push(ann);
    pushUndo({action:'add', page: state.pageNum, ann});
  } else if(state.tool === 'highlight'){
    const ann = { type:'highlight', x, y, w, h, color: hexToRgba(state.draw.color, 0.35) };
    ensurePageAnnotations(state.pageNum).push(ann);
    pushUndo({action:'add', page: state.pageNum, ann});
  }
  shapeStart = null;
  clearCanvas(drawCtx);
  drawAllAnnotationsForPage(state.pageNum);
});

/* ---------- Helpers ---------- */
function hexToRgba(hex, alpha){
  const c = hex.replace('#','');
  const bigint = parseInt(c,16);
  const r = (bigint>>16)&255, g=(bigint>>8)&255, b=bigint&255;
  return `rgba(${r},${g},${b},${alpha})`;
}

/* ---------- Undo / Redo ---------- */
function pushUndo(item){
  state.undoStack.push(item);
  if(state.undoStack.length>100) state.undoStack.shift();
  updateUndoRedoButtons();
}
function updateUndoRedoButtons(){ undoBtn.disabled = state.undoStack.length===0; redoBtn.disabled = state.redoStack.length===0; }
undoBtn.addEventListener('click', ()=> {
  if(state.undoStack.length===0) return;
  const item = state.undoStack.pop();
  // handle basic actions: add => remove last matching, replaceTextbox => swap prev
  if(item.action==='add'){
    const arr = ensurePageAnnotations(item.page);
    const idx = arr.lastIndexOf(item.ann);
    if(idx>-1) arr.splice(idx,1);
    else {
      // try to remove by matching type and content if necessary
      const found = arr.findIndex(a => JSON.stringify(a) === JSON.stringify(item.ann));
      if(found>-1) arr.splice(found,1);
    }
  } else if(item.action==='replaceTextbox'){
    state.annotations[item.page] = item.prev;
  }
  state.redoStack.push(item);
  drawAllAnnotationsForPage(state.pageNum);
  updateUndoRedoButtons();
});
redoBtn.addEventListener('click', ()=> {
  if(state.redoStack.length===0) return;
  const item = state.redoStack.pop();
  if(item.action==='add'){ ensurePageAnnotations(item.page).push(item.ann); }
  else if(item.action==='replaceTextbox'){ state.annotations[item.page] = item.next; }
  state.undoStack.push(item);
  drawAllAnnotationsForPage(state.pageNum);
  updateUndoRedoButtons();
});

/* ---------- Export / Import Annotations JSON ---------- */
exportJSON.addEventListener('click', ()=> {
  const payload = {
    meta:{ fileName: state.fileName, exportedAt: new Date().toISOString() },
    annotations: state.annotations
  };
  const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = (state.fileName.replace(/\.pdf$/i,'')||'annotations') + '_annotations.json'; a.click();
});
importJSON.addEventListener('click', ()=> importFile.click());
importFile.addEventListener('change', e=> {
  const f = e.target.files[0];
  if(!f) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const obj = JSON.parse(reader.result);
      state.annotations = obj.annotations || {};
      drawAllAnnotationsForPage(state.pageNum);
      showToast('Annotations imported');
    } catch(err){ showToast('Invalid JSON'); }
  };
  reader.readAsText(f);
  e.target.value = '';
});

/* ---------- Page navigation & zoom ---------- */
prevPage.addEventListener('click', async ()=> {
  if(state.pageNum > 1){ state.pageNum--; await renderPage(); }
});
nextPage.addEventListener('click', async ()=> {
  if(state.pageNum < state.pageCount){ state.pageNum++; await renderPage(); }
});
zoomIn.addEventListener('click', async ()=> { state.scale = Math.min(3, state.scale + 0.2); zoomReset.textContent = Math.round(state.scale*100)+'%'; await renderPage(); });
zoomOut.addEventListener('click', async ()=> { state.scale = Math.max(0.4, state.scale - 0.2); zoomReset.textContent = Math.round(state.scale*100)+'%'; await renderPage(); });
zoomReset.addEventListener('click', async ()=> { state.scale = 1.2; zoomReset.textContent = '100%'; await renderPage(); });

/* ---------- Color / width controls ---------- */
colorPick.addEventListener('input', e => state.draw.color = e.target.value);
widthPick.addEventListener('input', e => state.draw.width = Number(e.target.value) || 1);

/* ---------- Save (flatten) using pdf-lib ---------- */
saveBtn.addEventListener('click', async ()=> {
  if(!state.pdfBytes){ showToast('No PDF loaded'); return; }
  showToast('Preparing PDF export — flattening annotations...');
  try {
    // load original pdf
    const pdfDoc = await PDFLib.PDFDocument.load(state.pdfBytes);
    // for each page, rasterize anno layer + textboxes (we'll draw DOM elements into an image)
    for(let p=1; p<=state.pageCount; p++){
      const page = pdfDoc.getPage(p-1);
      // get page size in points
      const { width: pageW, height: pageH } = page.getSize();
      // create a canvas at CSS size of our viewer for this page
      // render PDF page again into an offscreen canvas at 1:1 CSS pixels
      const pdfPage = await state.pdfDoc.getPage(p);
      const viewport = pdfPage.getViewport({scale: state.scale});
      // We'll create a temp canvas matching viewport (CSS pixels)
      const tmp = document.createElement('canvas');
      tmp.width = Math.floor(viewport.width); tmp.height = Math.floor(viewport.height);
      const tmpCtx = tmp.getContext('2d');
      // draw the rendered PDF page onto tmp using PDF.js render (render to an offscreen canvas)
      // Note: Using page.render to existing context requires a canvas with backing store scaled — instead, render to an offscreen canvas using getViewport(scale=1)
      const renderTask = pdfPage.render({ canvasContext: tmpCtx, viewport: viewport });
      await renderTask.promise;
      // draw annotations for page onto tmp (merge anno and text DOM)
      // draw raster annotations (we have dataURLs in state.annotations)
      const anns = state.annotations[p] || [];
      for(const ann of anns){
        if(ann.type === 'drawing'){
          const img = new Image();
          await new Promise((res,rej) => { img.onload = res; img.onerror = rej; img.src = ann.img; });
          tmpCtx.drawImage(img, 0, 0, tmp.width, tmp.height);
        } else if(ann.type === 'textbox'){
          // draw textbox background and text
          tmpCtx.fillStyle = ann.bg || '#ffffff';
          tmpCtx.fillRect(ann.x, ann.y, ann.w, ann.h);
          tmpCtx.strokeStyle = ann.border || '#3498db';
          tmpCtx.strokeRect(ann.x, ann.y, ann.w, ann.h);
          tmpCtx.fillStyle = ann.color || '#000';
          tmpCtx.font = '14px sans-serif';
          // simple text wrapping
          const lines = (ann.text || '').split('\n');
          let tx = ann.x + 6, ty = ann.y + 18;
          for(const line of lines){
            tmpCtx.fillText(line, tx, ty);
            ty += 18;
          }
        } else if(ann.type === 'shape'){
          tmpCtx.save();
          tmpCtx.lineWidth = ann.strokeWidth || 2;
          tmpCtx.strokeStyle = ann.stroke || '#000';
          tmpCtx.fillStyle = ann.fill || 'rgba(0,0,0,0)';
          if(ann.shapeType === 'rect'){
            tmpCtx.fillRect(ann.x, ann.y, ann.w, ann.h);
            tmpCtx.strokeRect(ann.x, ann.y, ann.w, ann.h);
          } else if(ann.shapeType === 'ellipse'){
            tmpCtx.beginPath();
            tmpCtx.ellipse(ann.x + ann.w/2, ann.y + ann.h/2, Math.abs(ann.w/2), Math.abs(ann.h/2), 0, 0, Math.PI*2);
            tmpCtx.fill(); tmpCtx.stroke();
          } else if(ann.shapeType === 'arrow'){
            tmpCtx.beginPath();
            tmpCtx.moveTo(ann.x, ann.y);
            tmpCtx.lineTo(ann.x + ann.w, ann.y + ann.h);
            tmpCtx.stroke();
            tmpCtx.beginPath();
            tmpCtx.moveTo(ann.x + ann.w, ann.y + ann.h);
            tmpCtx.lineTo(ann.x + ann.w - 10, ann.y + ann.h - 6);
            tmpCtx.lineTo(ann.x + ann.w - 6, ann.y + ann.h - 10);
            tmpCtx.closePath(); tmpCtx.fill();
          }
          tmpCtx.restore();
        } else if(ann.type === 'highlight'){
          tmpCtx.fillStyle = ann.color || 'rgba(255,255,0,0.35)';
          tmpCtx.fillRect(ann.x, ann.y, ann.w, ann.h);
        }
      } // end for annotations

      // Now embed tmp canvas image into pdf-lib page
      const imgDataUrl = tmp.toDataURL('image/png');
      const imgBytes = await fetch(imgDataUrl).then(r => r.arrayBuffer());
      const img = await pdfDoc.embedPng(imgBytes);
      // compute scale to fit PDF page sizes: our tmp canvas width/height correspond to viewport CSS pixels.
      // Map tmp.width -> pageW points, tmp.height -> pageH points
      const imgDims = img.scale(1);
      const xScale = pageW / tmp.width;
      const yScale = pageH / tmp.height;
      // draw image to cover whole page
      page.drawImage(img, { x: 0, y: 0, width: pageW, height: pageH });
    } // end page loop

    // finalize
    const outBytes = await pdfDoc.save();
    const blob = new Blob([outBytes], {type:'application/pdf'});
    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = state.fileName; a.click();
    showToast('PDF exported');
  } catch(err){
    console.error(err);
    showToast('Export failed');
  }
});

/* ---------- Print ---------- */
printBtn.addEventListener('click', ()=> window.print());

/* ---------- Draw annotations initially (if any) ---------- */
function drawAllAnnotationsForPageWrapper(){
  drawAllAnnotationsForPage(state.pageNum);
}
window.addEventListener('resize', ()=> {
  // re-render page to adapt sizes
  if(state.pdfDoc) renderPage();
});

/* ---------- Page initialization: create default annotations holder ---------- */
function initEmptyAnnotations(){ for(let i=1;i<=state.pageCount;i++) if(!state.annotations[i]) state.annotations[i]=[]; }

/* ---------- Misc: update undo/redo initial ---------- */
updateUndoRedoButtons();

/* ---------- On load: minimal setup ---------- */
// nothing more — waiting for user to upload

</script>
</body>
</html>
